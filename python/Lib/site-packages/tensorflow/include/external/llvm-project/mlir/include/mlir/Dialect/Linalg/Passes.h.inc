/* Autogenerated by mlir-tblgen; don't manually edit */
#ifdef GEN_PASS_CLASSES

//===----------------------------------------------------------------------===//
// LinalgFoldUnitExtentDims
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class LinalgFoldUnitExtentDimsBase : public ::mlir::FunctionPass {
public:
  LinalgFoldUnitExtentDimsBase() : ::mlir::FunctionPass(::mlir::TypeID::get<DerivedT>()) {}
  LinalgFoldUnitExtentDimsBase(const LinalgFoldUnitExtentDimsBase &) : ::mlir::FunctionPass(::mlir::TypeID::get<DerivedT>()) {}

  /// Returns the command-line argument attached to this pass.
  llvm::StringRef getArgument() const override { return "linalg-fold-unit-extent-dims"; }

  /// Returns the derived pass name.
  llvm::StringRef getName() const override { return "LinalgFoldUnitExtentDims"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

protected:
  Pass::Option<bool> foldOneTripLoopsOnly{*this, "fold-one-trip-loops-only", llvm::cl::desc("Only folds the one-trip loops from Linalg ops on tensors (for testing purposes only)"), llvm::cl::init(false)};
};

//===----------------------------------------------------------------------===//
// LinalgFusion
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class LinalgFusionBase : public ::mlir::FunctionPass {
public:
  LinalgFusionBase() : ::mlir::FunctionPass(::mlir::TypeID::get<DerivedT>()) {}
  LinalgFusionBase(const LinalgFusionBase &) : ::mlir::FunctionPass(::mlir::TypeID::get<DerivedT>()) {}

  /// Returns the command-line argument attached to this pass.
  llvm::StringRef getArgument() const override { return "linalg-fusion"; }

  /// Returns the derived pass name.
  llvm::StringRef getName() const override { return "LinalgFusion"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

protected:
};

//===----------------------------------------------------------------------===//
// LinalgFusionOfTensorOps
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class LinalgFusionOfTensorOpsBase : public ::mlir::OperationPass<> {
public:
  LinalgFusionOfTensorOpsBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  LinalgFusionOfTensorOpsBase(const LinalgFusionOfTensorOpsBase &) : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}

  /// Returns the command-line argument attached to this pass.
  llvm::StringRef getArgument() const override { return "linalg-fusion-for-tensor-ops"; }

  /// Returns the derived pass name.
  llvm::StringRef getName() const override { return "LinalgFusionOfTensorOps"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

protected:
};

//===----------------------------------------------------------------------===//
// LinalgLowerToAffineLoops
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class LinalgLowerToAffineLoopsBase : public ::mlir::FunctionPass {
public:
  LinalgLowerToAffineLoopsBase() : ::mlir::FunctionPass(::mlir::TypeID::get<DerivedT>()) {}
  LinalgLowerToAffineLoopsBase(const LinalgLowerToAffineLoopsBase &) : ::mlir::FunctionPass(::mlir::TypeID::get<DerivedT>()) {}

  /// Returns the command-line argument attached to this pass.
  llvm::StringRef getArgument() const override { return "convert-linalg-to-affine-loops"; }

  /// Returns the derived pass name.
  llvm::StringRef getName() const override { return "LinalgLowerToAffineLoops"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

protected:
};

//===----------------------------------------------------------------------===//
// LinalgLowerToLoops
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class LinalgLowerToLoopsBase : public ::mlir::FunctionPass {
public:
  LinalgLowerToLoopsBase() : ::mlir::FunctionPass(::mlir::TypeID::get<DerivedT>()) {}
  LinalgLowerToLoopsBase(const LinalgLowerToLoopsBase &) : ::mlir::FunctionPass(::mlir::TypeID::get<DerivedT>()) {}

  /// Returns the command-line argument attached to this pass.
  llvm::StringRef getArgument() const override { return "convert-linalg-to-loops"; }

  /// Returns the derived pass name.
  llvm::StringRef getName() const override { return "LinalgLowerToLoops"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

protected:
};

//===----------------------------------------------------------------------===//
// LinalgLowerToParallelLoops
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class LinalgLowerToParallelLoopsBase : public ::mlir::FunctionPass {
public:
  LinalgLowerToParallelLoopsBase() : ::mlir::FunctionPass(::mlir::TypeID::get<DerivedT>()) {}
  LinalgLowerToParallelLoopsBase(const LinalgLowerToParallelLoopsBase &) : ::mlir::FunctionPass(::mlir::TypeID::get<DerivedT>()) {}

  /// Returns the command-line argument attached to this pass.
  llvm::StringRef getArgument() const override { return "convert-linalg-to-parallel-loops"; }

  /// Returns the derived pass name.
  llvm::StringRef getName() const override { return "LinalgLowerToParallelLoops"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

protected:
};

//===----------------------------------------------------------------------===//
// LinalgOnTensorsToBuffers
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class LinalgOnTensorsToBuffersBase : public ::mlir::OperationPass<ModuleOp> {
public:
  LinalgOnTensorsToBuffersBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  LinalgOnTensorsToBuffersBase(const LinalgOnTensorsToBuffersBase &) : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}

  /// Returns the command-line argument attached to this pass.
  llvm::StringRef getArgument() const override { return "convert-linalg-on-tensors-to-buffers"; }

  /// Returns the derived pass name.
  llvm::StringRef getName() const override { return "LinalgOnTensorsToBuffers"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

protected:
};

//===----------------------------------------------------------------------===//
// LinalgPromotion
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class LinalgPromotionBase : public ::mlir::FunctionPass {
public:
  LinalgPromotionBase() : ::mlir::FunctionPass(::mlir::TypeID::get<DerivedT>()) {}
  LinalgPromotionBase(const LinalgPromotionBase &) : ::mlir::FunctionPass(::mlir::TypeID::get<DerivedT>()) {}

  /// Returns the command-line argument attached to this pass.
  llvm::StringRef getArgument() const override { return "linalg-promote-subviews"; }

  /// Returns the derived pass name.
  llvm::StringRef getName() const override { return "LinalgPromotion"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

protected:
  Pass::Option<bool> dynamicBuffers{*this, "test-promote-dynamic", llvm::cl::desc("Test generation of dynamic promoted buffers"), llvm::cl::init(false)};
};

//===----------------------------------------------------------------------===//
// LinalgTiling
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class LinalgTilingBase : public ::mlir::FunctionPass {
public:
  LinalgTilingBase() : ::mlir::FunctionPass(::mlir::TypeID::get<DerivedT>()) {}
  LinalgTilingBase(const LinalgTilingBase &) : ::mlir::FunctionPass(::mlir::TypeID::get<DerivedT>()) {}

  /// Returns the command-line argument attached to this pass.
  llvm::StringRef getArgument() const override { return "linalg-tile"; }

  /// Returns the derived pass name.
  llvm::StringRef getName() const override { return "LinalgTiling"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

protected:
  Pass::ListOption<int64_t> tileSizes{*this, "linalg-tile-sizes", llvm::cl::desc("Test generation of dynamic promoted buffers"), llvm::cl::ZeroOrMore, llvm::cl::MiscFlags::CommaSeparated};
};

//===----------------------------------------------------------------------===//
// LinalgTilingToParallelLoops
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class LinalgTilingToParallelLoopsBase : public ::mlir::FunctionPass {
public:
  LinalgTilingToParallelLoopsBase() : ::mlir::FunctionPass(::mlir::TypeID::get<DerivedT>()) {}
  LinalgTilingToParallelLoopsBase(const LinalgTilingToParallelLoopsBase &) : ::mlir::FunctionPass(::mlir::TypeID::get<DerivedT>()) {}

  /// Returns the command-line argument attached to this pass.
  llvm::StringRef getArgument() const override { return "linalg-tile-to-parallel-loops"; }

  /// Returns the derived pass name.
  llvm::StringRef getName() const override { return "LinalgTilingToParallelLoops"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

protected:
  Pass::ListOption<int64_t> tileSizes{*this, "linalg-tile-sizes", llvm::cl::desc("Test generation of dynamic promoted buffers"), llvm::cl::ZeroOrMore, llvm::cl::MiscFlags::CommaSeparated};
};
#undef GEN_PASS_CLASSES
#endif // GEN_PASS_CLASSES
#ifdef GEN_PASS_REGISTRATION
#define GEN_PASS_REGISTRATION_LinalgFoldUnitExtentDims
#define GEN_PASS_REGISTRATION_LinalgFusion
#define GEN_PASS_REGISTRATION_LinalgFusionOfTensorOps
#define GEN_PASS_REGISTRATION_LinalgLowerToAffineLoops
#define GEN_PASS_REGISTRATION_LinalgLowerToLoops
#define GEN_PASS_REGISTRATION_LinalgLowerToParallelLoops
#define GEN_PASS_REGISTRATION_LinalgOnTensorsToBuffers
#define GEN_PASS_REGISTRATION_LinalgPromotion
#define GEN_PASS_REGISTRATION_LinalgTiling
#define GEN_PASS_REGISTRATION_LinalgTilingToParallelLoops
#endif // GEN_PASS_REGISTRATION
#ifdef GEN_PASS_REGISTRATION_LinalgFoldUnitExtentDims
::mlir::registerPass("linalg-fold-unit-extent-dims", "Remove unit-extent dimension in Linalg ops on tensors", []() -> std::unique_ptr<Pass> { return mlir::createLinalgFoldUnitExtentDimsPass(); });
#endif // GEN_PASS_REGISTRATION_LinalgFoldUnitExtentDims
#undef GEN_PASS_REGISTRATION_LinalgFoldUnitExtentDims
#ifdef GEN_PASS_REGISTRATION_LinalgFusion
::mlir::registerPass("linalg-fusion", "Fuse operations in the linalg dialect", []() -> std::unique_ptr<Pass> { return mlir::createLinalgFusionPass(); });
#endif // GEN_PASS_REGISTRATION_LinalgFusion
#undef GEN_PASS_REGISTRATION_LinalgFusion
#ifdef GEN_PASS_REGISTRATION_LinalgFusionOfTensorOps
::mlir::registerPass("linalg-fusion-for-tensor-ops", "Fuse operations on RankedTensorType in linalg dialect", []() -> std::unique_ptr<Pass> { return mlir::createLinalgFusionOfTensorOpsPass(); });
#endif // GEN_PASS_REGISTRATION_LinalgFusionOfTensorOps
#undef GEN_PASS_REGISTRATION_LinalgFusionOfTensorOps
#ifdef GEN_PASS_REGISTRATION_LinalgLowerToAffineLoops
::mlir::registerPass("convert-linalg-to-affine-loops", "Lower the operations from the linalg dialect into affine loops", []() -> std::unique_ptr<Pass> { return mlir::createConvertLinalgToAffineLoopsPass(); });
#endif // GEN_PASS_REGISTRATION_LinalgLowerToAffineLoops
#undef GEN_PASS_REGISTRATION_LinalgLowerToAffineLoops
#ifdef GEN_PASS_REGISTRATION_LinalgLowerToLoops
::mlir::registerPass("convert-linalg-to-loops", "Lower the operations from the linalg dialect into loops", []() -> std::unique_ptr<Pass> { return mlir::createConvertLinalgToLoopsPass(); });
#endif // GEN_PASS_REGISTRATION_LinalgLowerToLoops
#undef GEN_PASS_REGISTRATION_LinalgLowerToLoops
#ifdef GEN_PASS_REGISTRATION_LinalgLowerToParallelLoops
::mlir::registerPass("convert-linalg-to-parallel-loops", "Lower the operations from the linalg dialect into parallel loops", []() -> std::unique_ptr<Pass> { return mlir::createConvertLinalgToParallelLoopsPass(); });
#endif // GEN_PASS_REGISTRATION_LinalgLowerToParallelLoops
#undef GEN_PASS_REGISTRATION_LinalgLowerToParallelLoops
#ifdef GEN_PASS_REGISTRATION_LinalgOnTensorsToBuffers
::mlir::registerPass("convert-linalg-on-tensors-to-buffers", "Convert the Linalg operations which work on tensor-type operands or results to use buffers instead", []() -> std::unique_ptr<Pass> { return mlir::createConvertLinalgOnTensorsToBuffersPass(); });
#endif // GEN_PASS_REGISTRATION_LinalgOnTensorsToBuffers
#undef GEN_PASS_REGISTRATION_LinalgOnTensorsToBuffers
#ifdef GEN_PASS_REGISTRATION_LinalgPromotion
::mlir::registerPass("linalg-promote-subviews", "Promote subview ops to local buffers", []() -> std::unique_ptr<Pass> { return mlir::createLinalgPromotionPass(); });
#endif // GEN_PASS_REGISTRATION_LinalgPromotion
#undef GEN_PASS_REGISTRATION_LinalgPromotion
#ifdef GEN_PASS_REGISTRATION_LinalgTiling
::mlir::registerPass("linalg-tile", "Tile operations in the linalg dialect", []() -> std::unique_ptr<Pass> { return mlir::createLinalgTilingPass(); });
#endif // GEN_PASS_REGISTRATION_LinalgTiling
#undef GEN_PASS_REGISTRATION_LinalgTiling
#ifdef GEN_PASS_REGISTRATION_LinalgTilingToParallelLoops
::mlir::registerPass("linalg-tile-to-parallel-loops", "Tile operations in the linalg dialect to parallel loops", []() -> std::unique_ptr<Pass> { return mlir::createLinalgTilingToParallelLoopsPass(); });
#endif // GEN_PASS_REGISTRATION_LinalgTilingToParallelLoops
#undef GEN_PASS_REGISTRATION_LinalgTilingToParallelLoops
#ifdef GEN_PASS_REGISTRATION
#undef GEN_PASS_REGISTRATION_LinalgFoldUnitExtentDims
#undef GEN_PASS_REGISTRATION_LinalgFusion
#undef GEN_PASS_REGISTRATION_LinalgFusionOfTensorOps
#undef GEN_PASS_REGISTRATION_LinalgLowerToAffineLoops
#undef GEN_PASS_REGISTRATION_LinalgLowerToLoops
#undef GEN_PASS_REGISTRATION_LinalgLowerToParallelLoops
#undef GEN_PASS_REGISTRATION_LinalgOnTensorsToBuffers
#undef GEN_PASS_REGISTRATION_LinalgPromotion
#undef GEN_PASS_REGISTRATION_LinalgTiling
#undef GEN_PASS_REGISTRATION_LinalgTilingToParallelLoops
#endif // GEN_PASS_REGISTRATION
#undef GEN_PASS_REGISTRATION
